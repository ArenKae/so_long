/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   check_map_bonus.c                                  :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: acosi <acosi@student.42nice.fr>            +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2023/09/27 02:07:52 by acosi             #+#    #+#             */
/*   Updated: 2023/09/29 20:58:50 by acosi            ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../so_long.h"

//	Initializes all game-related integers variables  
//	inside the 'context' structure.

void	init_map_data(t_context **context)
{
	(*context)->player = 0;
	(*context)->collectibles = 0;
	(*context)->exit = 0;
	(*context)->moves = 0;
	(*context)->patrol = 0;
	(*context)->flag = 0;
	(*context)->loop = 0;
}

//	Parses through the whole map to find every P, E, C or X characters
//	and increments the corresponding variable accordingly. 

void	count_map_data(t_context **context, char **map, int x, int y)
{
	int	height;
	int	width;

	height = (*context)->map_height;
	width = (*context)->map_width;
	while (y < height)
	{
		while (x < width)
		{
			if (map[y][x] == 'P')
				(*context)->player++;
			if (map[y][x] == 'E')
				(*context)->exit++;
			if (map[y][x] == 'C')
				(*context)->collectibles++;
			if (map[y][x] == 'X')
				(*context)->patrol++;
			x++;
		}
		x = 0;
		y++;
	}
}

//	Check that the map contains exactly : 1 player spawn (P) ;
//	1 exit (E) and at least 1 collectible (C).

int	check_map_data(t_context **context)
{
	if ((*context)->player != 1)
		return (0);
	if ((*context)->exit != 1)
		return (0);
	if ((*context)->collectibles <= 0)
		return (0);
	return (1);
}

/*
	Calculate the size of the window in relation to the dimensions
	of the map. Every sprite is an image of 50x50 pixels, so the width
	and height of the map are multiplied by 50.
	We add 30 pixels to the height in order to create a black strip at 
	the bottom of the window, where additionnal game data will be 
	displayed (moves count, collectibles).
	mlx_get_screen_size() checks the size of the screen and return 0
	if the window generated by the current map would not fit the screen.
*/

int	get_window_size(t_context *context)
{
	int	tmp;
	int	x;
	int	y;

	x = 0;
	y = 0;
	tmp = context->map_width;
	context->window_x = tmp * 50;
	context->window_y = context->map_height * 50 + 30;
	if (context->game == NULL)
		return (1);
	mlx_get_screen_size(context->game, &x, &y);
	if (context->window_x > x)
		return (0);
	if (context->window_y > y)
		return (0);
	return (1);
}

/*
	Error handling function to check if the map is valid.
	First, it performs some basic verifications to check if the map
	is dimensionally and syntactically correct. If so, additionnal data
	about the map are collected and stored in variables from the context
	structure. This data will then be used to perform an advanced check
	to verify that the map has a valid layout allowing the exit and the
	collectibles to be reached by the player. If any of the checks fail
	at any point, the program stop and the corresponding error message
	is displayed in the terminal. Finally, after the map has passed all 
	the checks, the window size is calculated accordingly.
*/

int	check_map(t_context **context, char **map)
{
	if (!check_map_height(context, map))
		return (print_error(1));
	if (!check_map_width(context, map))
		return (print_error(1));
	if (!check_map_edges(context, map, 0, 0))
		return (print_error(1));
	if (!check_map_letters(context, map))
		return (print_error(1));
	init_map_data(context);
	count_map_data(context, map, 0, 0);
	if (!check_map_data(context))
		return (print_error(1));
	if (!init_check_valid_path(context, map, -1, -1))
		return (print_error(0));
	get_window_size(*context);
	return (1);
}
